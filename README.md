<img alt="Pixel art computer with a tin can on screen" src="https://github.com/user-attachments/assets/949ea187-336b-400d-8ce5-0e4671883a76" align="left"></img>

<div align="center">
  <div id="user-content-toc">
    <ul>
      <summary><h1 style="display: inline-block;">Tin</h1></summary>
    </ul>
    <i>Can you parse terminal input?</i><br />No, but a <b>Tin</b> can!
    <br /><br />
    <h4>
      <a href="#bindings">⛓️ Bindings</a> &nbsp-&nbsp <a href="#examples">📖 Examples</a> &nbsp-&nbsp <a href="#quirks">⚙️ Quirks</a> &nbsp-&nbsp <a href="#examples">🔨 Build</a> &nbsp-&nbsp <a href="#contributors">❤️ Contributors</a>
    </h3>
  </div>
</div>

---

# Goal
**Tin** aims to address a problem given to us by our ancestors—though they may not have been aware of it then...
Terminals have been around since at least 1967 (even earlier if you count teletypewriters), and their specifications have evolved over the years.
Notable milestones include the release of the VT52 and VT100 systems, which introduced control codes for tasks such as cursor movement and text styling (e.g., bold and underline).
While these features have remained relatively unchanged, input handling has not.
Beyond basic abc's and 123's, terminal input has varied widely across systems.

Fast forward to today, backward-compatible jargon has made handling terminal input quite a challenge.
Tin is designed as an "avoidance" library that simplifies development while supporting *most* of your terminal’s input capabilities.

# Bindings
If you've created bindings *please create a PR with your bindings in the table!*

# Examples
I am a huge fan of learning by example. As such, I have created many small examples to demonstrate how to use the library.

*insert said examples here*
